<!DOCTYPE html>
<html>
	<head>
		<meta charset="UTF-8">
		<meta content="width=device-width, initial-scale=1.0" name="viewport">
		<meta content="yes" name="mobile-web-app-capable">
		<title>Fractal image generation</title>
		<style>
			html, body {
				margin: 0;
				padding: 0;
			}
			body {
				display: grid;
				position: fixed;
				height: 100%;
				width: 100%;
			}
			canvas {
				align-self: center;
				justify-self: center;
			}
			#input-console{
				position: absolute;
				bottom: 0px;
				right: 0px;
				background: white;
				padding: 4px;
				opacity: 0;
			}
			#input-console:hover{
				opacity: 1;
			}
		</style>
		<script>
			'use strict'
			const urlSearchParams = new URLSearchParams(window.location.search);
			const corners = (()=>{
				const c = urlSearchParams.get('corners');
				if(c){
					if(c.includes(',')){
						return c;
					}
					return Math.max(3, parseInt(c ?? -1));
				}
				return 3;
			})();
			const cornerPlacement = urlSearchParams.get('cornerPlacement') ?? 'even';
			if(window.location.search === ''){
				window.location.search = 'corners='+(localStorage.getItem('corners') ?? corners)+'&cornerPlacement='+(localStorage.getItem('cornerPlacement') ?? cornerPlacement);
			}
			let x, y;
			function inputChange(event){
				if(event){
					localStorage.setItem('backgroundColor', event.value);
					document.body.style.backgroundColor = event.value;
				}
				[...heatMode.selectedOptions].forEach(o => {
					localStorage.setItem('heatMode', o.value);
				});
				localStorage.setItem('cbxInverted', cbxInverted.checked);
			}
			function reloadChange(){
				const numCorners = document.getElementById('numCorners');
				const selectCornerPlacement = document.getElementById('cornerPlacement');
				let cornerPlacement;
				[...selectCornerPlacement.selectedOptions].forEach(o => {
					cornerPlacement = o.value;
				});
				if(!cornerPlacement){
					cornerPlacement = 'even';
				}
				localStorage.setItem('cornerPlacement', cornerPlacement);
				localStorage.setItem('corners', numCorners.value);
				window.location.search = 'corners='+numCorners.value+'&cornerPlacement='+cornerPlacement;
			}
			function hslToRgb(h, s, l){ // Source: https://github.com/optimisme/javascript-temperatureMap/blob/ba64de1931b5c33bbc0171629364ae9ec06dc97c/temperatureMap.js#L57
				let r, g, b, hue2rgb, q, p;
				if(s === 0){
					r = g = b = l;
				}else{
					hue2rgb = function hue2rgb(p, q, t){
						if(t < 0){
							t += 1;
						}else if (t > 1){
							t -= 1;
						}
						if(t >= 0.66){
							return p;
						}else if(t >= 0.5){
							return p + (q - p) * (0.66 - t) * 6;
						}else if (t >= 0.33){
							return q;
						}else{
							return p + (q - p) * 6 * t;
						}
					};
					q = l < 0.5 ? l * (1 + s) : l + s - l * s;
					p = 2 * l - q;
					r = hue2rgb(p, q, h + 0.33);
					g = hue2rgb(p, q, h);
					b = hue2rgb(p, q, h - 0.33);
				}
				return [(r * 255) | 0, (g * 255) | 0, (b * 255) | 0]; // (x << 0) = Math.floor(x)
			}
			function onload(){
				const frameSize = Math.min(document.body.offsetWidth, document.body.offsetHeight);
				const canvas = document.getElementById('canvas');
				canvas.width = frameSize;
				canvas.height = frameSize;
				const canvasContext = canvas.getContext('2d');
				const imageData = canvasContext.getImageData(0, 0, frameSize, frameSize);
				const numCorners = document.getElementById('numCorners');
				const selectCornerPlacement = document.getElementById('cornerPlacement');
				const cbxInverted = document.getElementById('cbxInverted');
				const backgroundColorSelector = document.getElementById('colorBackground');
				const heatMode = document.getElementById('heatMode');
				numCorners.value = corners.split ? corners.split(',').length : corners;
				[...selectCornerPlacement.options].forEach(o => {
					o.selected = localStorage.getItem('cornerPlacement') === o.value;
				});
				[...heatMode.options].forEach(o => {
					o.selected = localStorage.getItem('heatMode') === o.value;
				});
				cbxInverted.checked = localStorage.getItem('cbxInverted') === 'true';
				document.body.style.backgroundColor = backgroundColorSelector.value = localStorage.getItem('backgroundColor') ?? '#000000';
				if(window.Worker){
					const worker = new Worker('worker.js');
					worker.postMessage({
						frameSize,
						corners: getCorners(corners, frameSize)
					});
					worker.onmessage = function(e){
						let min = e.data.max;
						e.data.imageData.forEach(i => {
							if(0 < i){
								min = Math.min(min, i);
							}
						});
						const diff = e.data.max - min;
						if(diff){
							const inverted = cbxInverted.checked;
							let rgb;
							e.data.imageData.forEach((i, index) => {
								index *= 4;
								let ratio = i ? (i-min)/diff : 0;
								[...heatMode.selectedOptions].forEach(o => {
									switch(o.value){
										default:
										case 'heatmap7':
											if(ratio < 1/7){
												ratio /= 1/7;
												rgb = [255*ratio, 0, 0];
											}else if(6/7 <= ratio){
												ratio = Math.abs(ratio-1);
												ratio /= 1/7;
												rgb = [255*ratio, 255*ratio, 255];
											}else{
												ratio = (ratio - 1/7)/(5/7);
												rgb = hslToRgb(ratio, 1, .5);
											}
											imageData.data[index] = rgb[0];
											imageData.data[index+1] = rgb[1];
											imageData.data[index+2] = rgb[2];
											break;
										case 'heatmap5':
											rgb = hslToRgb(ratio, 1, .5);
											imageData.data[index] = rgb[0];
											imageData.data[index+1] = rgb[1];
											imageData.data[index+2] = rgb[2];
											break;
										case 'grayscale':
											imageData.data[index] =
											imageData.data[index+1] =
											imageData.data[index+2] = Math.round(ratio*255);
											break;
										case 'mono':
											imageData.data[index] =
											imageData.data[index+1] =
											imageData.data[index+2] = ratio ? 255 : 0;
											break;
									}
									if(inverted){
										imageData.data[index] = 255-imageData.data[index];
										imageData.data[index+1] = 255-imageData.data[index+1];
										imageData.data[index+2] = 255-imageData.data[index+2];
									}
								});
								imageData.data[index+3] = i ? 255 : 0;
							})
							canvasContext.putImageData(imageData, 0, 0);
						}
						window.requestAnimationFrame(()=>{worker.postMessage(null)});
					};
				}else{
					document.body.innerHTML = 'No support for Web Workers.<br>' + document.body.innerHTML;
				}
			}
			function getCorners(numberOfCorners, frameSize){
				const center = frameSize/2;;
				const cornerList = [];
				const imageSizeHalf = Math.floor(frameSize/2);
				if(numberOfCorners.split){
					document.getElementById('reloadWrapper').style.display = 'none';
					if(numberOfCorners.includes(';')){
						numberOfCorners.split(';').forEach(g => {
							const c = g.split(',').map(c => parseFloat(c));
							cornerList.push({
								x: c[0]*imageSizeHalf + center,
								y: -c[1]*imageSizeHalf + center
							});
						});
					}else{
						numberOfCorners.split(',').forEach(d => {
							let dir = parseFloat(d) * (Math.PI/180);
							while(dir < 0){
								dir += Math.PI*2;
							}
							cornerList.push({
								x: Math.sin(dir)*imageSizeHalf + center,
								y: -Math.cos(dir)*imageSizeHalf + center
							});
						});
					}
				}else{
					switch(cornerPlacement){
						default:
						case 'even':
							const cornerAngle = (Math.PI*2) / numberOfCorners;
							for(let index = 0; index < numberOfCorners; index++){
								const dir = cornerAngle * index;
								cornerList.push({
									x: Math.sin(dir)*imageSizeHalf + center,
									y: -Math.cos(dir)*imageSizeHalf + center
								});
							}
							break;
						case 'random-pos':
							for(let index = 0; index < numberOfCorners; index++){
								cornerList.push({
									x: Math.floor(Math.random() * frameSize),
									y: Math.floor(Math.random() * frameSize)
								});
							}
							break;
						case 'random-angle':
							for(let index = 0; index < numberOfCorners; index++){
								const dir = Math.random() * Math.PI*2;
								cornerList.push({
									x: Math.sin(dir)*imageSizeHalf + center,
									y: -Math.cos(dir)*imageSizeHalf + center
								});
							}
							break;
					}
				}
				let largest_x = 0;
				let largest_y = 0;
				cornerList.forEach(corner => {
					corner.x -= imageSizeHalf;
					largest_x = Math.max(largest_x, corner.x);
					largest_y = Math.max(largest_y, corner.y);
				});
				cornerList.forEach(corner => {
					corner.x += imageSizeHalf;
					corner.y += (frameSize-largest_y)/2;
				});
				return cornerList;
			}
		</script>
	</head>
	<body onload="onload()">
		<canvas id="canvas"></canvas>
		<div id="input-console">
			<div id="reloadWrapper">
				Corners <input id="numCorners" type="number" min="3" onchange="reloadChange()">
				<br>
				Corner placement
				<select id="cornerPlacement" onchange="reloadChange()">
					<option value="even">Even</option>
					<option value="random-angle">Random angle</option>
					<option value="random-pos">Random pos</option>
				</select>
				<br>
			</div>
			Heat mode
			<select id="heatMode" onchange="inputChange()">
				<option value="heatmap7">7 heatmap</option>
				<option value="heatmap5">5 heatmap</option>
				<option value="grayscale">Gray scale</option>
				<option value="mono">Mono</option>
			</select>
			<br>
			Inverted <input id="cbxInverted" type="checkbox" onchange="inputChange()">
			<br>
			Background color <input id="colorBackground" type="color" oninput="inputChange(this)">
		</div>
	</body>
</html>
