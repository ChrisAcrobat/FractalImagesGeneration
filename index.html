<!DOCTYPE html>
<html>
	<head>
		<meta charset="UTF-8">
		<title>Fractal image generation</title>
		<style>
			html, body {
				margin: 0;
				padding: 0;
				background: black;
			}
			body {
				display: grid;
				position: fixed;
				height: 100%;
				width: 100%;
			}
			canvas {
				align-self: center;
				justify-self: center;
			}
			#input-console{
				position: absolute;
				bottom: 0px;
				right: 0px;
				background: white;
				padding: 4px;
				opacity: 0;
			}
			#input-console:hover{
				opacity: 1;
			}
		</style>
		<script>
			'use strict'
			const urlSearchParams = new URLSearchParams(window.location.search);
			const corners = Math.max(3, parseInt(urlSearchParams.get('corners') ?? -1));
			const cornerPlacement = Math.max(0, parseInt(urlSearchParams.get('cornerPlacement') ?? -1));	// 0: Even, 1: Random pos, 2: Random angle

			let x, y;
			function inputChange(event){
				[...heatMode.selectedOptions].forEach(o => {
					localStorage.setItem('heatMode', o.value);
				});
			}
			function hslToRgb(h, s, l){ // Source: https://github.com/optimisme/javascript-temperatureMap/blob/ba64de1931b5c33bbc0171629364ae9ec06dc97c/temperatureMap.js#L57
				let r, g, b, hue2rgb, q, p;
				if(s === 0){
					r = g = b = l;
				}else{
					hue2rgb = function hue2rgb(p, q, t){
						if(t < 0){
							t += 1;
						}else if (t > 1){
							t -= 1;
						}
						if(t >= 0.66){
							return p;
						}else if(t >= 0.5){
							return p + (q - p) * (0.66 - t) * 6;
						}else if (t >= 0.33){
							return q;
						}else{
							return p + (q - p) * 6 * t;
						}
					};
					q = l < 0.5 ? l * (1 + s) : l + s - l * s;
					p = 2 * l - q;
					r = hue2rgb(p, q, h + 0.33);
					g = hue2rgb(p, q, h);
					b = hue2rgb(p, q, h - 0.33);
				}
				return [(r * 255) | 0, (g * 255) | 0, (b * 255) | 0]; // (x << 0) = Math.floor(x)
			}
			function onload(){
				const frameSize = Math.min(document.body.offsetWidth, document.body.offsetHeight);
				const canvas = document.getElementById('canvas');
				canvas.width = frameSize;
				canvas.height = frameSize;
				const canvasContext = canvas.getContext('2d');
				const imageData = canvasContext.getImageData(0, 0, frameSize, frameSize);
				const heatMode = document.getElementById('heatMode');
				[...heatMode.options].forEach(o => {
					o.selected = localStorage.getItem('heatMode') === o.value;
				});
				if(window.Worker){
					const worker = new Worker('worker.js');
					worker.postMessage({
						frameSize,
						corners: getCorners(corners, frameSize)
					});
					worker.onmessage = function(e){
						let min = e.data.max;
						e.data.imageData.forEach(i => {
							if(0 < i){
								min = Math.min(min, i);
							}
						});
						const diff = e.data.max - min;
						if(diff){
							e.data.imageData.forEach((i, index) => {
								index *= 4;
								const ratio = i ? (i-min)/diff : 0;
								[...heatMode.selectedOptions].forEach(o => {
									switch(o.value){
										case 'spectrum':
											const rgb = hslToRgb(ratio, 1, .5);
											imageData.data[index] = rgb[0];
											imageData.data[index+1] = rgb[1];
											imageData.data[index+2] = rgb[2];
											break;
										case 'white':
											imageData.data[index] =
											imageData.data[index+1] =
											imageData.data[index+2] = Math.round(ratio*255);
											break;
										case 'black':
											imageData.data[index] =
											imageData.data[index+1] =
											imageData.data[index+2] = 255-Math.round(ratio*255);
											break;
									}
								});
								imageData.data[index+3] = i ? 255 : 0;
							})
							canvasContext.putImageData(imageData, 0, 0);
						}
						window.requestAnimationFrame(()=>{worker.postMessage(null)});
					};
				}else{
					document.body.innerHTML = 'No support for Web Workers.<br>' + document.body.innerHTML;
				}
			}
			function getCorners(numberOfCorners, frameSize){
				let cornerList = [];
				let imageSizeHalf = Math.floor(frameSize/2);
				switch(cornerPlacement){
					default:	// 0: Even
						var cornerAngle = (Math.PI*2) / numberOfCorners;
						var center = frameSize/2;
						for(var index = 0; index < numberOfCorners; index++){
							var dir = cornerAngle * index;
							var x = Math.sin(dir)*imageSizeHalf + center;
							var y = -Math.cos(dir)*imageSizeHalf + center;
							cornerList.push({x, y});
						}
						break;
					case 1:	// Random pos
						for(var index = 0; index < numberOfCorners; index++){
							var x = Math.floor(Math.random() * frameSize);
							var y = Math.floor(Math.random() * frameSize);
							cornerList.push({x, y});
						}
						break;
					case 2:	// Random angle
						var center = frameSize/2;
						for(var index = 0; index < numberOfCorners; index++){
							var dir = Math.random() * Math.PI*2;
							var x = Math.sin(dir)*imageSizeHalf + center;
							var y = -Math.cos(dir)*imageSizeHalf + center;
							cornerList.push({x, y});
						}
						break;
				}
				let largest_x = 0;
				let largest_y = 0;
				cornerList.forEach(corner => {
					corner.x -= imageSizeHalf;
					largest_x = Math.max(largest_x, corner.x);
					largest_y = Math.max(largest_y, corner.y);
				});
				let ratio = 1+(imageSizeHalf-largest_x)/imageSizeHalf;
				cornerList.forEach(corner => {
					corner.x *= ratio;
					corner.x += imageSizeHalf;
					corner.y *= ratio;
					corner.y += (frameSize-largest_y)/2;
				});
				return cornerList;
			}
		</script>
	</head>
	<body onload="onload()">
		<canvas id="canvas"></canvas>
		<div id="input-console">
			Heat mode
			<select id="heatMode" onchange="inputChange()">
				<option value="spectrum">Spectrum</option>
				<option value="white">White hot</option>
				<option value="black">Black hot</option>
			</select>
		</div>
	</body>
</html>
